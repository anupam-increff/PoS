---
description:    In test sources convert legacy association access   (getWarehouse(), setWarehouse(…)) to the new FK-Id   methods (getWarehouseId(), setWarehouseId(…)).   Also create / extend a single TestData utility that   factories all entities needed in tests.   The test cases functionality should remain as it is, dont change the case for which test has been written, if refacotring is too tough you can rewrite the way that test is written but make sure the test cases is implemented properly using the new mechanism to write the test.   # ═══════════════════════════════════════════════════════════   # TEST ORGANIZATION STRUCTURE (Plan Module Pattern)   # ═══════════════════════════════════════════════════════════   Tests should be organized in this clean directory structure:   src/test/java/com/increff/wms/core/{module}/   ├── unit/                     # All unit tests (isolated, fast, mocked dependencies)   │   ├── api/                  # API layer unit tests   │   ├── dao/                  # DAO layer unit tests   │   └── flow/                 # Flow layer unit tests   └── integration/              # Integration tests (database, external dependencies)       └── dto/                  # DTO integration tests organized by domain           ├── {domain}/         # Each domain gets its own subdirectory           │   ├── {Domain}CreationIntegrationTests.java           │   ├── {Domain}UpdateIntegrationTests.java           │   └── Get{Domain}IntegrationTests.java           └── {otherdomain}/   Example for plan module (REFERENCE IMPLEMENTATION):   - unit/api/PlanApiTest.java, ConfigApiTest.java, CriteriaApiTest.java   - unit/dao/PlanDaoTest.java, ConfigDaoTest.java, CriteriaDaoTest.java   - unit/flow/PlanFlowApiTest.java   - integration/dto/plan/PlanCreationIntegrationTests.java, GetPlanIntegrationTests.java   - integration/dto/config/ConfigCreationIntegrationTests.java, ConfigUpdateIntegrationTests.java   - integration/dto/criteria/CriteriaCreationIntegrationTests.java   # ───────────────────────────────────────────────────────────   # Integration Test Naming Conventions   # ───────────────────────────────────────────────────────────   - Creation tests: {Entity}CreationIntegrationTests.java   - Update tests: {Entity}UpdateIntegrationTests.java   - Retrieval tests: Get{Entity}IntegrationTests.java   - Upload tests: {Entity}UploadIntegrationTests.java   - Complex operations: {Entity}{Operation}IntegrationTests.java   For refactoring tests in dto directory, we need to consider all the tests present in that directory as integration tests. If needed we can break the existing classes such that each class represent a flow, for eg: I have only one dto class for outboundOrder which is OutboundOrderDto but the tests for that class can be broken  into multiple classes like OutboundOrderCreationIntegrationTests, OutboundShipmentCreationDtoIntegrationTests, OutboundShipmentFetchDtoIntegrationTests etc. We need to use the global TestData class present in /wms-core/src/test/java/com/increff/wms/core/setup/TestData.java for preparing the test data of these test and not the test classes that are defined within that directory.   There is an issue with some of the integration tests as well, every integration test, tests exactly one method of the data, and all the dependencies or testData required by that method is fulfilled by autowiring the corresponding dao api and persisting that data, we need proper assertions as well, for all the tests which involve database entity being updated/inserted, verify and assert the same using both the data that is returned by the dto method and also by using a select method of the dao class. # ─────────────────────────────── # Example of dao usage in integrationt tests # ─────────────────────────────── - test:         @Test     public void testCreateAndRemoveBayLevelMappings() throws ApiException {         CorePlanInterface mockPlan = mock(CorePlanInterface.class);         when(mockPlan.isBayEnabled()).thenReturn(true);         try (MockedStatic<CorePlanInitializerConfig> mockedStatic = mockStatic(CorePlanInitializerConfig.class)) {             mockedStatic.when(CorePlanInitializerConfig::getCurrentCorePlan).thenReturn(mockPlan);             // Setup - Create zone through integration flow             List<ZoneForm> zoneForms = new ArrayList<>();             ZoneForm zoneForm = new ZoneForm();             zoneForm.setCode("ZONE-001");             zoneForm.setPosition(0);             zoneForms.add(zoneForm);             List<ZoneData> zones = locationDtoApi.createZones(zoneForms);             // Create aisle through integration flow             List<AisleForm> aisleForms = new ArrayList<>();             AisleForm aisleForm = new AisleForm();             aisleForm.setAisleCode("AISLE-001");             aisleForm.setZoneCode(zones.get(0).getCode());             aisleForm.setPosition(0);             aisleForms.add(aisleForm);             List<AisleData> aisles = locationDtoApi.createAisles(aisleForms);             // Create bay through integration flow with FK-Id reference             List<BayForm> bayForms = new ArrayList<>();             BayForm bayForm = new BayForm();             bayForm.setBayCode("BAY-001");             bayForm.setAisleId(aisles.get(0).getId());             bayForm.setPosition(0);             bayForms.add(bayForm);             List<BayData> bays = locationDtoApi.createBays(bayForms);             // Create level through integration flow             List<LevelForm> levelForms = new ArrayList<>();             LevelForm levelForm = new LevelForm();             levelForm.setCode("LEVEL-001");             levelForm.setPosition(0);             levelForms.add(levelForm);             List<LevelData> levels = locationDtoApi.createLevels(levelForms);             // Create mapping form for integration test             List<BayLevelForm> createForms = new ArrayList<>();             BayLevelForm form = new BayLevelForm();             form.setBayCode("BAY-001");             form.setLevelCode("LEVEL-001");             createForms.add(form);             // Execute - Create mapping through DTO method             List<BayLevelMappingData> result = locationDtoApi.createBayLevelMappings(createForms);             // Verify DTO method results             assertEquals(1, result.size());             assertNotNull(result);             assertNotNull(result.get(0).getBayId());             assertNotNull(result.get(0).getLevelId());             assertEquals(bays.get(0).getId(), result.get(0).getBayId());             assertEquals(levels.get(0).getId(), result.get(0).getLevelId());             // Verify database state using DAO select method             BayLevelMapping dbMapping = bayLevelDao.selectByBayAndLevel(bays.get(0).getId(), levels.get(0).getId());             assertNotNull(dbMapping);             assertEquals(result.get(0).getBayId(), dbMapping.getBayId());             assertEquals(result.get(0).getLevelId(), dbMapping.getLevelId());             // Test removal through DTO method             locationDtoApi.removeBayLevelMappings(createForms);             // Verify removal in database using DAO select method             BayLevelMapping dbMappingAfterRemoval = bayLevelDao.selectByBayAndLevel(bays.get(0).getId(), levels.get(0).getId());             assertNull(dbMappingAfterRemoval);             // Verify removal by creating again - should work if removal was successful             List<BayLevelMappingData> newResult = locationDtoApi.createBayLevelMappings(createForms);             assertNotNull(newResult);             assertEquals(1, newResult.size());             assertEquals(bays.get(0).getId(), newResult.get(0).getBayId());             assertEquals(levels.get(0).getId(), newResult.get(0).getLevelId());         }     }     in the above tests locationDtoApi.createAisles(aisleForms), createZone etc should not have been called, instead we should have created the data required for the tests using the TestData class and then the corresponding aisleDao, zoneDao's create methods should be called # ─────────────────────────────── # Which files the rule touches # ─────────────────────────────── globs:   - "src/test/**/*.java"   # Organized test structure patterns   - "src/test/**/unit/api/**/*Test.java"                    # API layer unit tests   - "src/test/**/unit/dao/**/*Test.java"                    # DAO layer unit tests    - "src/test/**/unit/flow/**/*Test.java"                   # Flow layer unit tests   - "src/test/**/integration/dto/**/*IntegrationTests.java" # DTO integration tests # ─────────────────────────────── # 1. setters that still pass the entity object #    order.setWarehouse(wh)  ->  order.setWarehouseId(wh.getId()) # ─────────────────────────────── - find: |     $OBJ$.set$Cap{FIELD}$($ENTITY$);   replace: |     $OBJ$.set$Cap{FIELD}Id($ENTITY$.getId());   variables:     OBJ:        {kind: expression}     ENTITY:     {kind: expression}     FIELD:      {kind: text} # ─────────────────────────────── # 2. getters that chain through the object to get the id #    order.getWarehouse().getId()  ->  order.getWarehouseId() # ─────────────────────────────── - find: |     $OBJ$.get$Cap{FIELD}$().getId()   replace: |     $OBJ$.get$Cap{FIELD}Id()   variables:     OBJ:   {kind: expression}     FIELD: {kind: text} # ─────────────────────────────── # 3. assertions comparing object.getId() #    assertEquals(order.getWarehouse().getId(), 42) #      -> assertEquals(order.getWarehouseId(), 42) # ─────────────────────────────── - find: |     assert$ASSERT$($LEFT$.get$Cap{FIELD}$().getId(), $RIGHT$)   replace: |     assert$ASSERT$($LEFT$.get$Cap{FIELD}Id(), $RIGHT$)   variables:     ASSERT: {kind: text}        # Equals, True, ... – whatever JUnit/Hamcrest call     LEFT:   {kind: expression}     RIGHT:  {kind: expression}     FIELD:  {kind: text} # ─────────────────────────────── # 4. make sure a single TestData helper exists #    (Cursor will append new factories when the rule runs again) # ─────────────────────────────── - ensure_file:     path: /wms-core/src/test/java/com/increff/wms/core/setup/TestData.java     content: |       package com.increff.wms.util;       /**        * Centralised factories for lightweight test objects.        * Add methods here instead of duplicating builders        * across individual test classes.        */       public final class TestData {           private TestData() {}   // utility class – no instances           /* ---------- Warehouses ---------- */           public static Warehouse warehouse(int id) {               Warehouse wh = new Warehouse();               wh.setId(id);               wh.setName("WH-" + id);               return wh;           }           /* ---------- Tasks ---------- */           public static Task task(int id, int warehouseId) {               Task t = new Task();               t.setId(id);               t.setWarehouseId(warehouseId);               // add other mandatory fields if/when needed               return t;           }           // Cursor will automatically append new factory           // methods the first time an unfamiliar entity           // appears in a rewritten test.       }
globs: 
alwaysApply: false
---
